from telegram import Update, BotCommand, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackQueryHandler, MessageHandler, filters
import logging
import random
import asyncio
import os
from datetime import time, datetime, timedelta
import pytz
from flask import Flask
import threading

# Configurar logging para ver errores
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# Crear app Flask para health checks de Render
app = Flask(__name__)

@app.route('/')
def home():
    return "ü§ñ Bot de Telegram funcionando correctamente ‚úÖ", 200

@app.route('/health')
def health():
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}, 200

# Datos de asignaturas actualizados con IDs consistentes
SUBJECTS = {
    "introduccion_biblia": {
        "name": "Introducci√≥n a la Biblia",
        "resources": "https://t.me/semholguincentro/11"
    },
    "psicologia": {
        "name": "Psicolog√≠a",
        "resources": "https://t.me/semholguincentro/9"
    },
    "historia_universal": {
        "name": "Historia Universal",
        "resources": "https://t.me/semholguincentro/17"
    },
    "historia_iglesia": {
        "name": "Historia de la Iglesia",
        "resources": "https://t.me/semholguincentro/18"
    },
    "liderazgo": {
        "name": "Liderazgo",
        "resources": "https://t.me/semholguincentro/23"
    },
    "liturgia": {
        "name": "Liturgia",
        "resources": "https://t.me/semholguincentro/35"
    },
    "metodos_estudio_biblico": {
        "name": "M√©todos de Estudio B√≠blico",
        "resources": "https://t.me/semholguincentro/25"
    },
    "homiletica": {
        "name": "Homil√©tica",
        "resources": "https://t.me/semholguincentro/13"
    },
    "metodismo_i_historia": {
        "name": "Metodismo I Historia",
        "resources": "https://t.me/semholguincentro/38"
    },
    "metodismo_ii_doctrina": {
        "name": "Metodismo II Doctrina",
        "resources": "https://t.me/semholguincentro/39"
    },
    "introduccion_teologia": {
        "name": "Introducci√≥n a la Teolog√≠a",
        "resources": "https://t.me/semholguincentro/15"
    },
    "tecnicas_estudio": {
        "name": "T√©cnicas de estudio",
        "resources": "https://t.me/semholguincentro/21"
    },
    "mision_evangelizacion": {
        "name": "Misi√≥n y Evangelizaci√≥n",
        "resources": "https://t.me/semholguincentro/20"
    },
    "computacion": {
        "name": "Computaci√≥n",
        "resources": "https://t.me/semholguincentro/19"
    },
    "ministerio_educativo_i": {
        "name": "Ministerio Educativo de la Iglesia I",
        "resources": "https://t.me/semholguincentro/10"
    },
    "musica_tradicion_cristiana": {
        "name": "M√∫sica en la tradici√≥n cristiana",
        "resources": "https://t.me/semholguincentro/16"
    },
    "dinamica_estructura": {
        "name": "Din√°mica de la estructura",
        "resources": "https://t.me/semholguincentro/24"
    },
    "redaccion_ortografia": {
        "name": "Redacci√≥n y Ortograf√≠a",
        "resources": "https://t.me/semholguincentro/12"
    }
}

# Base de datos de promesas b√≠blicas
BIBLE_PROMISES = [
     {"text": "Reconoce, pues, que el Se√±or tu Dios es Dios, el Dios fiel, que cumple su pacto y muestra su fiel amor por mil generaciones a quienes lo aman y obedecen sus mandamientos.", "reference": "Deuteronomio 7:9"},
     {"text": "Mi arco he puesto en las nubes, el cual ser√° por se√±al del pacto entre m√≠ y la tierra.", "reference": "G√©nesis 9:13"},
     {"text": "Y har√© mi pacto contigo, y te multiplicar√© en gran manera.", "reference": "G√©nesis 17:2"},
     {"text": "El Se√±or mismo va delante de ti y estar√° contigo; no te dejar√° ni te desamparar√°. No temas ni te intimides.", "reference": "Deuteronomio 31:8"},
     {"text": "Pero el amor leal del Se√±or es desde la eternidad y hasta la eternidad para los que le temen, y su justicia para los hijos de sus hijos; para los que guardan su pacto y se acuerdan de sus preceptos para ponerlos por obra.", "reference": "Salmos 103:17-18"},
     {"text": "Por eso, Cristo es mediador de un nuevo pacto, para que los llamados reciban la herencia eterna prometida, ahora que √©l ha muerto para liberarlos de los pecados cometidos bajo el primer pacto.", "reference": "Hebreos 9:15"},
     {"text": "Ahora, pues, si en verdad escuchan mi voz y guardan mi pacto, ser√°n mi especial tesoro entre todos los pueblos, porque toda la tierra es m√≠a.", "reference": "√âxodo 19:5"},
     {"text": "Y el Se√±or dijo a Mois√©s: Escribe t√∫ estas palabras, porque conforme a estas palabras he hecho pacto contigo y con Israel.", "reference": "√âxodo 34:27"},
     {"text": "Porque aunque los montes se corran y las colinas se tambaleen, mi amor leal no se apartar√° de ti, ni mi pacto de paz ser√° quebrantado ‚Äîdice el Se√±or, que tiene compasi√≥n de ti‚Äî.", "reference": "Isa√≠as 54:10"},
     {"text": "Pero ahora, a Jes√∫s se le ha confiado un ministerio muy superior, pues √©l es el mediador que nos garantiza un pacto mejor, basado en mejores promesas.", "reference": "Hebreos 8:6"}
]

# Mensajes de bienvenida aleatorios
WELCOME_MESSAGES = [
    "¬°Bienvenido {name} al Grupo del Seminario Evang√©lico Metodista Extensi√≥n Holgu√≠n! üéì Esperamos que las clases le sean de provecho para su edificaci√≥n en Cristo.",
]

# Almacenamiento simple de usuarios suscritos (en producci√≥n usar√≠as una base de datos)
subscribed_users = set()
# Almacenar la hora preferida de cada usuario
user_preferred_time = {}

class ClassBot:
    def __init__(self, token):
        self.token = token
        self.application = Application.builder().token(token).build()
        self.has_job_queue = hasattr(self.application, 'job_queue') and self.application.job_queue is not None
        self.setup_handlers()

    async def set_bot_commands(self):
        """Configurar los comandos del bot"""
        commands = [
            BotCommand("start", "üöÄ Iniciar conversaci√≥n con el Asistente Docente"),
            BotCommand("asignaturas", "üìö Ver lista de asignaturas"),
            BotCommand("bibliografia", "üìñ Ver bibliograf√≠a"),
            BotCommand("normas", "üìã Ver normas del grupo"),
            BotCommand("promesa", "üìñ Suscribirse a la promesa b√≠blica diaria"),
            BotCommand("help", "‚ùì Obtener ayuda")
        ]
        await self.application.bot.set_my_commands(commands)

    def setup_handlers(self):
        """Configurar los manejadores de comandos"""
        # Comandos normales
        self.application.add_handler(CommandHandler("start", self.start))
        self.application.add_handler(CommandHandler("asignaturas", self.list_subjects))
        self.application.add_handler(CommandHandler("bibliografia", self.list_bibliografia))
        self.application.add_handler(CommandHandler("normas", self.rules))
        self.application.add_handler(CommandHandler("promesa", self.promesa_diaria))
        self.application.add_handler(CommandHandler("help", self.help))

        # Handlers para botones interactivos
        self.application.add_handler(CallbackQueryHandler(self.subject_button, pattern="^subject_"))
        self.application.add_handler(CallbackQueryHandler(self.back_button, pattern="^back_to_"))
        self.application.add_handler(CallbackQueryHandler(self.promesa_button, pattern="^promesa_"))
        self.application.add_handler(CallbackQueryHandler(self.time_selection, pattern="^time_"))

        # ‚úÖ MANEJADOR PARA NUEVOS MIEMBROS (BIENVENIDA AUTOM√ÅTICA)
        self.application.add_handler(
            MessageHandler(
                filters.StatusUpdate.NEW_CHAT_MEMBERS,
                self.welcome_new_member
            )
        )
        
        # Programar la tarea diaria de enviar promesas b√≠blicas solo si JobQueue est√° disponible
        if self.has_job_queue:
            try:
                # Programar para cada hora del d√≠a para verificar las horas preferidas de los usuarios
                for hour in range(24):
                    self.application.job_queue.run_daily(
                        self.enviar_promesas_diarias,
                        time=time(hour=hour, minute=0, tzinfo=pytz.timezone('America/Havana')),
                        name=f"enviar_promesas_diarias_{hour}am"
                    )
                print("‚úÖ JobQueue configurado correctamente para promesas diarias (cada hora)")
            except Exception as e:
                print(f"‚ùå Error configurando JobQueue: {e}")
                self.has_job_queue = False
        else:
            print("‚ö†Ô∏è JobQueue no disponible. Las promesas diarias no se enviar√°n autom√°ticamente.")

    async def enviar_promesas_diarias(self, context: ContextTypes.DEFAULT_TYPE):
        """Enviar promesas b√≠blicas a todos los usuarios suscritos a la hora actual"""
        if not subscribed_users:
            print("‚è∞ No hay usuarios suscritos para enviar promesas b√≠blicas")
            return
            
        current_time = datetime.now(pytz.timezone('America/Havana'))
        current_hour = current_time.hour
        current_minute = current_time.minute
        
        promesa = random.choice(BIBLE_PROMISES)
        mensaje = f"üìñ Promesa B√≠blica del D√≠a:\n\n\"{promesa['text']}\"\n- {promesa['reference']}"
        
        for user_id in list(subscribed_users):
            try:
                # Verificar si es la hora preferida del usuario
                user_time = user_preferred_time.get(user_id, time(8, 0))  # Por defecto 8:00 AM
                
                # Solo enviar si es la hora programada por el usuario
                if user_time.hour == current_hour and user_time.minute == current_minute:
                    await context.bot.send_message(chat_id=user_id, text=mensaje)
                    print(f"‚úÖ Promesa enviada a usuario {user_id} a las {user_time}")
            except Exception as e:
                print(f"‚ùå Error enviando promesa a usuario {user_id}: {e}")
                # Si el usuario ha bloqueado el bot, eliminarlo de la lista
                if "bot was blocked" in str(e).lower():
                    subscribed_users.discard(user_id)
                    print(f"‚ö†Ô∏è Usuario {user_id} eliminado de suscripciones (bloque√≥ el bot)")

    async def send_promise_now(self, user_id):
        """Enviar una promesa b√≠blica inmediatamente al usuario"""
        promesa = random.choice(BIBLE_PROMISES)
        mensaje = f"üìñ Tu promesa b√≠blica de hoy:\n\n\"{promesa['text']}\"\n- {promesa['reference']}"
        
        try:
            await self.application.bot.send_message(chat_id=user_id, text=mensaje)
            print(f"‚úÖ Promesa inmediata enviada a usuario {user_id}")
        except Exception as e:
            print(f"‚ùå Error enviando promesa inmediata a usuario {user_id}: {e}")

    async def promesa_diaria(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manejar el comando para suscribirse/desuscribirse a las promesas diarias"""
        user_id = update.effective_user.id
        
        # Si JobQueue no est√° disponible, informar al usuario
        if not self.has_job_queue:
            await update.message.reply_text(
                "‚ö†Ô∏è La funci√≥n de promesas diarias autom√°ticas no est√° disponible en este momento. "
                "Puedes usar /promesa para recibir una promesa b√≠blica inmediata."
            )
            return
        
        # Si el usuario ya est√° suscrito
        if user_id in subscribed_users:
            keyboard = [
                [InlineKeyboardButton("‚úÖ S√≠, mantener suscripci√≥n", callback_data="promesa_keep")],
                [InlineKeyboardButton("üïê Cambiar hora de env√≠o", callback_data="promesa_time")],
                [InlineKeyboardButton("‚ùå No, cancelar suscripci√≥n", callback_data="promesa_cancel")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            user_time = user_preferred_time.get(user_id, time(8, 0))
            await update.message.reply_text(
                f"üìñ Ya est√°s suscrito a la Promesa B√≠blica Diaria.\n\nActualmente recibes las promesas a las {user_time.strftime('%H:%M')}.\n\n¬øQu√© deseas hacer?",
                reply_markup=reply_markup
            )
        else:
            keyboard = [
                [InlineKeyboardButton("‚úÖ S√≠, suscribirme", callback_data="promesa_subscribe")],
                [InlineKeyboardButton("‚ùå No, gracias", callback_data="promesa_decline")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                "üìñ ¬øTe gustar√≠a recibir una promesa b√≠blica cada d√≠a para fortalecer tu fe?\n\nPuedes cancelar en cualquier momento con /promesa",
                reply_markup=reply_markup
            )

    async def promesa_button(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manejar los botones de suscripci√≥n a promesas b√≠blicas"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        action = query.data.split("_")[1]
        
        if action == "subscribe":
            subscribed_users.add(user_id)
            # Establecer hora predeterminada si no existe
            if user_id not in user_preferred_time:
                user_preferred_time[user_id] = time(8, 0)  # 8:00 AM por defecto
            
            # Enviar promesa inmediata
            await self.send_promise_now(user_id)
            
            # Mostrar opciones para programar hora
            keyboard = [
                [InlineKeyboardButton("üïê Programar hora de env√≠o", callback_data="promesa_time")],
                [InlineKeyboardButton("‚úÖ Mantener hora predeterminada (8:00 AM)", callback_data="promesa_keep")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(
                "‚úÖ ¬°Te has suscrito a la Promesa B√≠blica Diaria!\n\nCada d√≠a recibir√°s una promesa de la Palabra de Dios para fortalecer tu fe.\n\n¬øDeseas programar una hora espec√≠fica para recibir las promesas?",
                reply_markup=reply_markup
            )
            
        elif action == "decline":
            await query.edit_message_text("‚ùå No te preocupes. Si cambias de opini√≥n, siempre puedes suscribirte despu√©s con el comando /promesa.")
            
        elif action == "keep":
            user_time = user_preferred_time.get(user_id, time(8, 0))
            await query.edit_message_text(f"‚úÖ Perfecto, seguir√°s recibiendo la Promesa B√≠blica Diaria a las {user_time.strftime('%H:%M')}. ¬°Dios bendiga tu d√≠a!")
            
        elif action == "cancel":
            if user_id in subscribed_users:
                subscribed_users.remove(user_id)
            await query.edit_message_text("‚ùå Has cancelado tu suscripci√≥n a la Promesa B√≠blica Diaria.\n\nSi cambias de opini√≥n, siempre puedes volver a suscribirte con /promesa.")
            
        elif action == "time":
            # Mostrar opciones de hora
            keyboard = [
                [InlineKeyboardButton("6:00 AM", callback_data="time_6_0")],
                [InlineKeyboardButton("7:00 AM", callback_data="time_7_0")],
                [InlineKeyboardButton("8:00 AM", callback_data="time_8_0")],
                [InlineKeyboardButton("9:00 AM", callback_data="time_9_0")],
                [InlineKeyboardButton("10:00 AM", callback_data="time_10_0")],
                [InlineKeyboardButton("5:00 PM", callback_data="time_17_0")],
                [InlineKeyboardButton("6:00 PM", callback_data="time_18_0")],
                [InlineKeyboardButton("7:00 PM", callback_data="time_19_0")],
                [InlineKeyboardButton("8:00 PM", callback_data="time_20_0")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(
                "üïê Selecciona la hora a la que prefieres recibir tu promesa b√≠blica diaria:",
                reply_markup=reply_markup
            )

    async def time_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manejar la selecci√≥n de hora para las promesas b√≠blicas"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        # Extraer hora y minutos del callback_data (formato: time_H_M)
        _, hour_str, minute_str = query.data.split("_")
        hour = int(hour_str)
        minute = int(minute_str)
        
        # Guardar la preferencia del usuario
        user_preferred_time[user_id] = time(hour, minute)
        
        # Asegurarse de que el usuario est√° suscrito
        subscribed_users.add(user_id)
        
        await query.edit_message_text(
            f"‚úÖ ¬°Hora programada correctamente!\n\nA partir de ahora recibir√°s tu promesa b√≠blica diaria a las {hour:02d}:{minute:02d}.\n\n¬°Dios bendiga tu d√≠a! üìñ"
        )

    async def welcome_new_member(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """‚úÖ Dar la bienvenida autom√°tica a nuevos miembros"""
        print("üîî Evento de nuevo miembro detectado!")

        # Verificar que hay nuevos miembros
        if not update.message or not update.message.new_chat_members:
            return

        for new_member in update.message.new_chat_members:
            # ‚ö†Ô∏è Evitar saludar al propio bot u otros bots
            if new_member.is_bot:
                print(f"‚ö†Ô∏è  Ignorando bot: {new_member.first_name}")
                continue

            print(f"üéì Saludando nuevo estudiante: {new_member.first_name}")

            # Seleccionar mensaje de bienvenida aleatorio
            welcome_message = random.choice(WELCOME_MESSAGES).format(
                name=new_member.first_name
            )

            # Mensaje de bienvenida completo
            full_welcome = f"""
{welcome_message}

üìã Para comenzar:
‚Ä¢ /asignaturas - Ver las materias
‚Ä¢ /bibliografia - Ver las bibliograf√≠as
‚Ä¢ /normas - Leer las reglas del grupo
‚Ä¢ /promesa - Recibir promesas b√≠blicas diarias
‚Ä¢ /help - Obtener ayuda

¬°No dudes en preguntar si tienes dudas! ü§ó
            """

            try:
                # Enviar mensaje de bienvenida al grupo
                await update.message.reply_text(full_welcome)
                print(f"‚úÖ Bienvenida enviada a {new_member.first_name} en el grupo")
                
                # Enviar mensaje privado al nuevo miembro
                try:
                    # Crear bot√≥n para iniciar conversaci√≥n privada
                    keyboard = [
                        [InlineKeyboardButton("üöÄ Iniciar conversaci√≥n privada", url=f"https://t.me/{context.bot.username}?start=start")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await context.bot.send_message(
                        chat_id=new_member.id,
                        text=f"üëã ¬°Hola {new_member.first_name}! Soy el asistente del Seminario. Haz clic en el bot√≥n para iniciar una conversaci√≥n privada conmigo donde podr√© ayudarte con informaci√≥n sobre las asignaturas, bibliograf√≠as y m√°s.",
                        reply_markup=reply_markup
                    )
                    print(f"‚úÖ Invitaci√≥n a chat privado enviada a {new_member.first_name}")
                except Exception as e:
                    print(f"‚ö†Ô∏è No se pudo enviar mensaje privado a {new_member.first_name}: {e}")

            except Exception as e:
                print(f"‚ùå Error enviando bienvenida al grupo: {e}")

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Mensaje de bienvenida"""
        user = update.effective_user
        chat_type = update.effective_chat.type
        
        # Si el comando se ejecuta en un grupo (no en privado)
        if chat_type in ["group", "supergroup"]:
            # Crear bot√≥n para iniciar conversaci√≥n privada
            keyboard = [
                [InlineKeyboardButton("üöÄ Iniciar conversaci√≥n privada", url=f"https://t.me/{context.bot.username}?start=start")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            welcome_text = f"""
üëã ¬°Hola {user.first_name}! 

Soy el Asistente Docente del Seminario Evang√©lico Metodista Extensi√≥n Holgu√≠n.

Para una mejor experiencia, te invito a iniciar una conversaci√≥n privada conmigo haciendo clic en el bot√≥n de abajo.

¬°All√≠ podr√© ayudarte con toda la informaci√≥n que necesites! üìö
            """
            await update.message.reply_text(welcome_text, reply_markup=reply_markup)
        else:
            # Conversaci√≥n privada
            welcome_text = f"""
üëã ¬°Hola {user.first_name}! Bienvenido al Asistente Docente del Seminario Evang√©lico Metodista Extensi√≥n Holgu√≠n!

üéì Esperamos que las clases le sean de provecho para su edificaci√≥n en Cristo.

Puedo brindar informaci√≥n sobre:
üìö /asignaturas - Ver lista de asignaturas
üìñ /bibliografia - Ver lista de bibliograf√≠a
üìã /normas - Ver reglas del grupo
üìñ /promesa - Recibir promesas b√≠blicas diarias
‚ùì /help - Obtener ayuda

¬°Espero que te sea √∫til!
            """
            await update.message.reply_text(welcome_text)
        
        # Configurar comandos despu√©s del start
        await self.set_bot_commands()

    async def list_subjects(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Mostrar lista de asignaturas con botones interactivos"""
        # Si el comando se ejecuta en un grupo, sugerir conversaci√≥n privada
        if update.effective_chat.type in ["group", "supergroup"]:
            keyboard = [
                [InlineKeyboardButton("üöÄ Ver asignaturas en privado", url=f"https://t.me/{context.bot.username}?start=asignaturas")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                "üìö Para consultar la lista completa de asignaturas, te invito a continuar la conversaci√≥n en privado:",
                reply_markup=reply_markup
            )
            return
            
        # Conversaci√≥n privada - mostrar la lista completa
        keyboard = []
        for subject_id, subject_info in SUBJECTS.items():
            keyboard.append([InlineKeyboardButton(
                subject_info["name"],
                callback_data=f"subject_{subject_id}"
            )])
        
        # Agregar bot√≥n "Volver al inicio" al final
        keyboard.append([InlineKeyboardButton(
            "‚óÄÔ∏è Volver al inicio", 
            callback_data="back_to_start"
        )])

        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "üìö Lista de Asignaturas:\n\nSelecciona una asignatura para ver m√°s detalles:",
            reply_markup=reply_markup
        )

    async def list_bibliografia(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Mostrar informaci√≥n de bibliograf√≠a con enlace directo y bot√≥n de regreso"""
        # Si el comando se ejecuta en un grupo, sugerir conversaci√≥n privada
        if update.effective_chat.type in ["group", "supergroup"]:
            keyboard = [
                [InlineKeyboardButton("üöÄ Ver bibliograf√≠a en privado", url=f"https://t.me/{context.bot.username}?start=bibliografia")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                "üìñ Para consultar la bibliograf√≠a completa, te invito a continuar la conversaci√≥n en privado:",
                reply_markup=reply_markup
            )
            return
            
        # Conversaci√≥n privada - mostrar la bibliograf√≠a completa
        print("üìñ Comando /bibliografia ejecutado")
        bibliografia_text = """
üìö Bibliograf√≠a Recomendada:

üîó Accede a toda la literatura aqu√≠:
https://t.me/semholguincentro/40
        """
        
        # Crear teclado con bot√≥n de regreso al inicio
        keyboard = [
            [InlineKeyboardButton("‚óÄÔ∏è Volver al inicio", callback_data="back_to_start")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            bibliografia_text,
            reply_markup=reply_markup
        )

    async def subject_button(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manejar la selecci√≥n de una asignatura"""
        query = update.callback_query
        await query.answer()

        # CORRECCI√ìN: Unir todas las partes despu√©s de "subject_"
        subject_id = "_".join(query.data.split("_")[1:])

        print(f"üîç Bot√≥n presionado: {query.data}")
        print(f"üîç ID de asignatura extra√≠do: {subject_id}")

        if subject_id in SUBJECTS:
            subject = SUBJECTS[subject_id]
            response_text = f"""
üìñ **{subject['name']}**

üîó Recursos: {subject['resources']}
            """
            print(f"‚úÖ Asignatura encontrada: {subject['name']}")
            await query.edit_message_text(
                text=response_text,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚óÄÔ∏è Volver a asignaturas", callback_data="back_to_subjects")]
                ])
            )
        else:
            print(f"‚ùå Asignatura no encontrada: {subject_id}")
            print(f"üìã Asignaturas disponibles: {list(SUBJECTS.keys())}")
            await query.edit_message_text(
                text="‚ùå Lo siento, no se pudo encontrar la informaci√≥n de esta asignatura.",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚óÄÔ∏è Volver a asignaturas", callback_data="back_to_subjects")]
                ])
            )

    async def back_button(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manejar botones de volver (tanto a asignaturas como al inicio)"""
        query = update.callback_query
        await query.answer()
        
        if query.data == "back_to_start":
            # Volver al mensaje de inicio
            user = query.from_user
            welcome_text = f"""
üëã ¬°Hola {user.first_name}! Bienvenido al Asistente Docente del Seminario Evang√©lico Metodista Extensi√≥n Holgu√≠n!

üéì Esperamos que las clases le sean de provecho para su edificaci√≥n en Cristo.

Puedo brindar informaci√≥n sobre:
üìö /asignaturas - Ver lista de asignaturas
üìñ /bibliografia - Ver lista de bibliograf√≠a
üìã /normas - Ver reglas del grupo
üìñ /promesa - Recibir promesas b√≠blicas diarias
‚ùì /help - Obtener ayuda

¬°Espero que te sea √∫til!
            """
            await query.edit_message_text(welcome_text)
            
        else:  # back_to_subjects
            # Volver a la lista de asignaturas
            keyboard = []
            for subject_id, subject_info in SUBJECTS.items():
                keyboard.append([InlineKeyboardButton(
                    subject_info["name"],
                    callback_data=f"subject_{subject_id}"
                )])
            
            # Agregar bot√≥n "Volver al inicio" al final
            keyboard.append([InlineKeyboardButton(
                "‚óÄÔ∏è Volver al inicio", 
                callback_data="back_to_start"
            )])

            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                "üìö **Lista de Asignaturas:**\n\nSelecciona una asignatura para ver m√°s detalles:",
                reply_markup=reply_markup
            )

    async def help(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Mostrar mensaje de ayuda"""
        # Si el comando se ejecuta en un grupo, sugerir conversaci√≥n privada
        if update.effective_chat.type in ["group", "supergroup"]:
            keyboard = [
                [InlineKeyboardButton("üöÄ Obtener ayuda en privado", url=f"https://t.me/{context.bot.username}?start=help")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                "‚ùì Para obtener ayuda completa, te invito a continuar la conversaci√≥n en privado:",
                reply_markup=reply_markup
            )
            return
            
        # Conversaci√≥n privada - mostrar la ayuda completa
        help_text = """
ü§ñ Bot de Gesti√≥n de Asignaturas

Comandos disponibles:
/start - Iniciar el bot
/asignaturas - Ver lista de asignaturas
/bibliografia - Ver bibliograf√≠a recomendada
/normas - Ver reglas del grupo
/promesa - Suscribirse a promesas b√≠blicas diarias
/help - Mostrar esta ayuda

Funcionalidades:
- Consultar informaci√≥n de asignaturas
- Recibir bienvenida autom√°tica al unirte
- Acceder a recursos de cada materia
- Recibir promesas b√≠blicas diarias
        """
        await update.message.reply_text(help_text)

    async def rules(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Mostrar normas del grupo"""
        # Si el comando se ejecuta en un grupo, sugerir conversaci√≥n privada
        if update.effective_chat.type in ["group", "supergroup"]:
            keyboard = [
                [InlineKeyboardButton("üöÄ Ver normas en privado", url=f"https://t.me/{context.bot.username}?start=normas")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                "üìã Para consultar las normas completas, te invito a continuar la conversaci√≥n en privado:",
                reply_markup=reply_markup
            )
            return
            
        # Conversaci√≥n privada - mostrar las normas completas
        rules_text = """
üìã Normas del Grupo de Clase:

1. üö´ No spam ni publicidad
2. üë• Respeto entre hermanos
3. üìö Mantener el enfoque en temas acad√©micos
4. üîá Evitar enlaces externos
5. ü§ù S√≥lo dudas con respecto al seminario

¬°Entre todos mantengamos un buen ambiente de aprendizaje! Dios los bendiga! üåü
        """
        await update.message.reply_text(rules_text)

def run_flask():
    """Ejecutar servidor Flask para health checks"""
    app.run(host='0.0.0.0', port=5000, debug=False)

def main():
    """Funci√≥n principal para Render"""
    # Obtener token de variable de entorno (para Render)
    BOT_TOKEN = os.environ.get('BOT_TOKEN')
    if not BOT_TOKEN:
        print("‚ùå Error: BOT_TOKEN no encontrado en variables de entorno")
        print("üí° Aseg√∫rate de configurar la variable BOT_TOKEN en Render")
        exit(1)

    print("ü§ñ Iniciando bot en Render...")
    print(f"üìö Total de asignaturas: {len(SUBJECTS)}")
    print(f"üìñ Total de promesas b√≠blicas: {len(BIBLE_PROMISES)}")
    
    # Iniciar servidor Flask en segundo plano para health checks
    flask_thread = threading.Thread(target=run_flask, daemon=True)
    flask_thread.start()
    print("üåê Servidor Flask iniciado para health checks (puerto 5000)")
    
    # Crear y ejecutar el bot
    bot = ClassBot(BOT_TOKEN)
    
    try:
        print("‚úÖ Bot iniciado correctamente")
        print("üìñ Comando /bibliografia incluye: https://t.me/semholguincentro/40")
        if bot.has_job_queue:
            print("üìñ JobQueue disponible: Promesas b√≠blicas diarias activadas")
        else:
            print("‚ö†Ô∏è JobQueue no disponible: Promesas diarias desactivadas")
        
        bot.application.run_polling()
        
    except Exception as e:
        print(f"‚ùå Error: {e}")

# üöÄ EJECUCI√ìN PARA RENDER
if __name__ == "__main__":

    main()
